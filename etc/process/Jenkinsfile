#!/usr/bin/env groovy

//
// Return a stage object that will get executed in the appropriate ontology-publisher container
//
def dockerScript_runInOntologyPublisherContainer(Map config, Closure body) {

  assert config.shortStageName != null
  assert config.longStageName != null
  assert body != null

  return {
    stage(config.longStageName) {

      echo "runInOntologyPublisherContainer shortStageName:${config.shortStageName}, longStageName:${config.longStageName}"

      def containerName = "ontology-publisher-${env.EXECUTOR_NUMBER}-${config.shortStageName}"

      node('docker') {
        echo "Running in stage \"${config.longStageName}\" now"
        sh "set"
        gitScript_checkOutGitRepos()
        if (config.unstashOutputDirs) {
          config.unstashOutputDirs.each { outputDir ->
            unstash "output-${outputDir}"
          }
        }
        //
        // Make sure that the output and tmp directories are there
        //
        sh "pwd"
        sh "rm -rf output tmp && install -dv output tmp"
        echo "Launching docker container ${containerName}:"
        try {
          def dockerImage = docker.image(env.ONTPUB_IMAGE)
          dockerImage.pull()
          dockerImage.inside("""
            --read-only
            --name ${containerName}
            --mount type=bind,source=${env.WORKSPACE}/input,target=/input,readonly,consistency=cached
            --mount type=bind,source=${env.WORKSPACE}/output,target=/output,consistency=delegated
            --mount type=bind,source=${env.WORKSPACE}/tmp,target=/var/tmp,consistency=delegated
          """) {
            echo "Running in docker container ${containerName}"
            //
            // Now execute whatever you had in the closure
            //
            body()
          }
        } catch (e) {
          currentBuild.result = "FAILURE"
          echo "Failed stage \"${config.longStageName}\": ${e}"
          throw e
        } finally {
          echo "Tasks in docker container ${containerName} executed successfully"
          if (config.archiveArtifacts == true) {
            archiveArtifacts artifacts: "output/fibo/${config.shortStageName}/**/*.log", fingerprint: true
          }
          slackScript_notifyStage()
        }
      }
    }
  }
}

def gitScript_checkOutGitRepos() {

  final String gitCredentialsId = '50cac519-d41c-4765-8563-c43b7f55c877'

  dir('input') {
    dir('fibo') {
      //
      // The fibo repo is the main repo which also has configuration in the global variable scm,
      // inherit those settings and add some more here.
      //
      checkout([
        $class                           : 'GitSCM',
        branches                         : scm.branches,
        doGenerateSubmoduleConfigurations: false,
        extensions                       : scm.extensions + [
          [$class: 'LocalBranch', localBranch: '**'],
          [$class: 'CheckoutOption', timeout: 1],
          [$class: 'AuthorInChangelog'],
          [$class: 'PruneStaleBranch'],
          [$class: 'IgnoreNotifyCommit']
        ],
        submoduleCfg                     : [],
        userRemoteConfigs                : scm.userRemoteConfigs + [
          [credentialsId: gitCredentialsId, url: 'https://github.com/edmcouncil/fibo.git']
        ]
      ])
    }
    dir('LCC') {
      //
      // The LCC repo is a secondary repo that we always use with its master branch. Do not inherit
      // from the scm settings here.
      //
      checkout([
        $class                           : 'GitSCM',
        branches                         : [[name: '*/master']],
        doGenerateSubmoduleConfigurations: false,
        extensions                       : [
          [$class: 'LocalBranch', localBranch: '**'],
          [$class: 'CheckoutOption', timeout: 1],
          [$class: 'AuthorInChangelog'],
          [$class: 'PruneStaleBranch'],
          [$class: 'IgnoreNotifyCommit']
        ],
        submoduleCfg                     : [],
        userRemoteConfigs                : [
          [credentialsId: gitCredentialsId, url: 'https://github.com/edmcouncil/LCC.git']
        ]
      ])
    }
  }
}

//
// Return the stage object that runs the hygiene tests
//
def publishScript_hygiene() {

  return dockerScript_runInOntologyPublisherContainer(
    shortStageName: 'hygiene',
    longStageName: 'Hygiene Tests'
  ) {
    sh "/publisher/publish.sh hygiene"
  }
}

//
// Return the stage that produces the output of the given product
//
def product(String product) {

  String[] unstashOutputDirs = []

  if (product != "ontology") {
    unstashOutputDirs = ['ontology']
  }

  return dockerScript_runInOntologyPublisherContainer(
    shortStageName: product,
    longStageName: "Build ${product.capitalize()}",
    archiveArtifacts: true,
    unstashOutputDirs: unstashOutputDirs
  ) {
    sh "/publisher/publish.sh ${product}"
    stash name: "output-${product}", includes: "output/fibo/${product}/**"
  }
}

//
// Return the stage object that runs the publish action
//
def publishScript_publish(String[] derivedProducts) {

  return dockerScript_runInOntologyPublisherContainer(
    shortStageName: 'publish',
    longStageName: 'Build Final Content',
    unstashOutputDirs: (derivedProducts - 'ontology')
  ) {
    //
    // Now after all the above is done, make sure we run the final
    // publish step which zips it all up into the output directory
    //
    sh "/publisher/publish.sh publish"
    //
    // Stash the artifacts generated by the publish command
    //
    dir('output') {
      stash([
        name              : 'publishable-output',
        includes          : '**',
        excludes          : '**/.git, **/.gitignore, **/.log, **/temp*, **/node_modules, **/build',
        useDefaultExcludes: true
      ])
    }
  }
}

import groovy.transform.Field
@Field private mainSlackMessageObject = null

def slackScript_init() {
  echo "Initialising slack functions"

  mainSlackMessageObject = slackSend(
    color: "good",
    message: "Started build <${env.BUILD_URL}|Build #${env.BUILD_NUMBER}> on branch ${env.JOB_NAME}",
    botUser: false,
    baseUrl: null,
    teamDomain: 'fibo-edmc'
  )

  if (mainSlackMessageObject == null) {
    echo "ERROR: Could not initialise slack connection"
  } else {
    println ("mainSlackMessageObject: " + mainSlackMessageObject.dump())
  }
}

def slackScript_send(String color, String message) {

  if (mainSlackMessageObject == null) {
    slackScript_init()
    if (mainSlackMessageObject == null) {
      slackSend color: color, message: "${message} (no main message)"
      return
    }
  }

  slackSend color: color, message: message, channel: mainSlackMessageObject.threadId, botUser: true
}

def slackScript_notifyStage() {

  String buildResult = currentBuild.currentResult

  def message="Stage \"${STAGE_NAME}\" finished with status ${buildResult} in <${env.BUILD_URL}|Build #${env.BUILD_NUMBER}> on branch ${env.JOB_NAME}"

  if (buildResult == "SUCCESS") {
    echo "${message}"
    slackScript_send("good", message)
  }
  else if (buildResult == "FAILURE") {
    echo "ERROR: ${message}"
    slackScript_send("danger", message)
  }
  else if (buildResult == "UNSTABLE") {
    echo "WARNING: ${message}"
    slackScript_send("warning", message)
  }
  else {
    echo "ERROR: ${message}"
    slackScript_send("danger", message)
  }
}

//
// The main Jenkinsfile for FIBO, defining the Build/Publish/Test/Deploy process that is
// executed for each push into the repository.
//
// Note that this file is in the so called "Declarative Pipeline" syntax
//
// See https://jenkins.io/doc/book/pipeline/jenkinsfile/
//
String[] derivedProducts = ['fibopedia', 'glossary', 'vocabulary', 'datadictionary','htmlpages']

env.ONTPUB_FAMILY='fibo'
env.ONTPUB_SPEC_HOST='spec.edmcouncil.org'
env.ONTPUB_IS_DARK_MODE='1'
env.ONTPUB_IMAGE='edmcouncil/ontology-publisher:v0.1.6'
env.LC_ALL='en_US.UTF-8'
env.LANG='en_US.UTF-8'
env.LANGUAGE='en_US.UTF-8'
env.NGINX_SPEC_ROOT='/mnt/jenkins-disk/spec.edmcouncil.org'

properties([
  buildDiscarder(
          logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '30')
  ),
])

node {
  ansiColor('xterm') {

    publishScript_hygiene().call()

    publishScript_product('ontology').call()

    stage('Build Derived Products') {
      def parallelStages = derivedProducts.collectEntries { product ->
        [ "Build ${product}" : publishScript_product(product)]
      }
      parallel(parallelStages)
    }

    publishScript_publish(derivedProducts).call()

    //
    // Run the publish on the master jenkins agent by just copying all the generated artifacts right into the workspace
    // on master and let NGINX just serve it from there.
    //
    // This workspace will never be "wiped" so it contains all the older versions as well, wiping this workspace
    // will be bad because we would lose all previously published versions
    //
    stage('Publish') {
      node('master') {
        try {

          echo "Cleaning workspace:"
          sh 'rm -rf ${WORKSPACE}/* || true'
          echo "Done cleaning"

          sh 'test -d ${NGINX_SPEC_ROOT}'
          sh 'ls -al ${NGINX_SPEC_ROOT}/'
          sh 'pwd'

          dir('output') {
            echo 'Unstashing the output of the publish stage'
            unstash 'publishable-output'
            sh 'pwd && ls -al && set'

            echo "Copy all generated content to ${NGINX_SPEC_ROOT}:"
            sh '''
              cp -vr . ${NGINX_SPEC_ROOT}/ > ${WORKSPACE}/published-files.log 2>&1 || true
              rc=$?
              if ((rc == 0)); then
                echo "Successfully copied all files to destination, see published-files.log in the workspace"
              else
                echo "Some files may not have been copied"
                tail published-files.log
                exit 1
              fi
            '''
          }
          //
          // Archive all log files (including published-files.log) so that they can easily be viewed from the
          // Jenkins job page
          //
          archiveArtifacts artifacts: '**/*.log', allowEmptyArchive: true
          //
        } catch (e) {
          currentBuild.result = "FAILURE"
          echo "Failed the \"${STAGE_NAME}\" stage: ${e}"
          throw e
        } finally {
          slackScript_notifyStage()
        }
      } // end of node('master')
    } // end of stage "Publish"
  } // end of ansiColor('xterm')
}
